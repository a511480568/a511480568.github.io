<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>眺望远方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="眺望远方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="眺望远方">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="眺望远方">
  
    <link rel="alternative" href="/atom.xml" title="眺望远方" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate">Yashon</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">博客首页</a></li>
                        
                            <li><a href="/works">作品展示</a></li>
                        
                            <li><a href="/about">留言打卡</a></li>
                        
                            <li><a href="/FrontEndGuide">前端导航</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="#" title="weibo">weibo</a>
                            
                                <a class="fl google" target="_blank" href="#" title="google">google</a>
                            
                                <a class="fl twitter" target="_blank" href="#" title="twitter">twitter</a>
                            
                                <a class="fl linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://luuman.github.io/">name</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">纯海迷、爱运动、爱交友、爱旅行、喜欢接触新鲜事物、迎接新的挑战，更爱游离于错综复杂的编码与逻辑中</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">Yashon</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">Yashon</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">博客首页</a></li>
                
                    <li><a href="/works">作品展示</a></li>
                
                    <li><a href="/about">留言打卡</a></li>
                
                    <li><a href="/FrontEndGuide">前端导航</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=PAkNDgsKBQ4MCnxNTRJfU1E" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/luuman" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
                    
                        <a class="google" target="_blank" href="#" title="google">google</a>
                    
                        <a class="twitter" target="_blank" href="#" title="twitter">twitter</a>
                    
                        <a class="linkedin" target="_blank" href="#" title="linkedin">linkedin</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-redis中的哨兵架构的相关知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/redis中的哨兵架构的相关知识/" class="article-date">
      <time datetime="2018-01-31T22:12:25.869Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>redis中的哨兵架构的相关知识</p>
<p>redis如果要能达到99.99%的高可用，就需要使用哨兵架构来维持，以下是哨兵的相关概念：</p>
<p><strong>哨兵的介绍</strong></p>
<p>sentinal，中文名：哨兵。哨兵是redis集群架构中非常重要的一个组件，主要功能如下：</p>
<ul>
<li><p>集群监控：负责监控master和slave进程是否正常工作</p>
</li>
<li><p>消息通知：如果某个redis实例有故障，那么哨兵就会发送消息作为报警告知管理员</p>
</li>
<li><p>故障转移：如果master node挂掉了，那么就会自动转移到slave node上作为一个新的master node</p>
</li>
<li><p>配置中心：如果故障转移发生了，通知客户端新的master地址</p>
</li>
</ul>
<p><strong>哨兵的核心</strong></p>
<ul>
<li><p>哨兵至少需要三个实例来保证自己的健壮性</p>
</li>
<li><p>哨兵 + redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</p>
</li>
<li><p>对于哨兵 + redis这种复杂的部署架构，尽量在测试环境和生产环境进行充足的测试和演练</p>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-redis replication以及master持久化对主从架构的安全意义" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/redis replication以及master持久化对主从架构的安全意义/" class="article-date">
      <time datetime="2018-01-31T22:12:09.932Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>redis replication以及master持久化对主从架构的安全意义</p>
<p>由于单机的redis一般只能支撑几万的QPS，如果想要支撑10万+的QPS，就需要做主从架构来支撑。</p>
<h5 id="redis-replication-基本原理"><a href="#redis-replication-基本原理" class="headerlink" title="redis replication 基本原理"></a>redis replication 基本原理</h5><p>基本原理如下：</p>
<h4 id="redis-replication核心机制"><a href="#redis-replication核心机制" class="headerlink" title="redis replication核心机制"></a>redis replication核心机制</h4><ol>
<li><p>redis采用异步方式复制数据到slave节点，不过redis2.8开始，slave node会周期性的确认自己每次复制的数据量</p>
</li>
<li><p>一个master node可以配置多个slave node</p>
</li>
<li><p>slave node也可以连接其他的slave node</p>
</li>
<li><p>slave node做复制的时候是不会block master node的正常工作的</p>
</li>
<li><p>slave node在复制的时候也不会block自己的查询工作的，它会旧的数据集来提供服务，但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</p>
</li>
<li><p>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以用来提高吞吐量</p>
</li>
</ol>
<h4 id="master的持久化对主从架构的安全意义"><a href="#master的持久化对主从架构的安全意义" class="headerlink" title="master的持久化对主从架构的安全意义"></a>master的持久化对主从架构的安全意义</h4><ul>
<li><p>如果采用了主从架构，那么建议开启master node的持久化</p>
</li>
<li><p>不建议用slave node作为master node的数据热备，因为那样的话，如果你关闭master的持久化，可能在master宕机重启的时候数据是空的，然后master node复制数据到slave node，那么slave node的数据也被清空了</p>
</li>
<li><p>即使采用了高可用机制（哨兵），slave node可以自动接管master node，但是也可能sentinal还没有检测到master failure，master node就自动重启了，还是会有上述导致清空slaver node数据的风险</p>
</li>
</ul>
<h4 id="redis主从架构复制的流程"><a href="#redis主从架构复制的流程" class="headerlink" title="redis主从架构复制的流程"></a>redis主从架构复制的流程</h4><ol>
<li><p>slave node启动，仅仅保存master node的信息，包括master node的host和IP，但是复制流程还没开始</p>
</li>
<li><p>slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket连接</p>
</li>
<li><p>slave node发送ping命令给master node</p>
</li>
<li><p>口令认证，如果master设置了requirepass，那么slave node必须发送slaveauth的口令过去认证</p>
</li>
<li><p>master node 第一次进行全量复制，将所有数据发送给slave node</p>
</li>
<li><p>master node后续持续将写命令，使用异步复制的方式发送给slave node</p>
</li>
</ol>
<p>如下图：</p>
<p><img src="https://github.com/a511480568/image/blob/master/%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png?raw=true" alt="redis主从架构复制流程图"></p>
<p><strong>全量复制</strong></p>
<ul>
<li><p>master执行bgsave，在本地生成一份rdb快照文件</p>
</li>
<li><p>master node将rdb快照文件发送给salve node，如果rdb复制时间超过60秒（repl-timeout），那么slave node就会认为复制失败，可以适当调节大这个参数</p>
</li>
<li><p>对于千兆网卡的机器，一般每秒传输100MB，6G文件，很可能超过60s</p>
</li>
<li><p>master node在生成rdb时，会将所有新的写命令缓存在内存中，在salve node保存了rdb之后，再将新的写命令复制给salve node</p>
</li>
<li><p>client-output-buffer-limit slave 256MB 64MB 60，如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败</p>
</li>
<li><p>slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中，同时基于旧的数据版本对外提供服务</p>
</li>
<li><p>如果slave node开启了AOF，那么会立即执行BGREWRITEAOF，重写AOF</p>
</li>
</ul>
<p><strong>增量复制</strong></p>
<ul>
<li><p>如果全量复制过程中，master-slave网络连接断掉，那么salve重新连接master时，会触发增量复制（使用run_id，offset等判断）</p>
</li>
<li><p>master直接从自己的backlog中获取部分丢失的数据，发送给slave node，默认backlog就是1MB</p>
</li>
<li><p>msater就是根据slave发送的psync中的offset来从backlog中获取数据的</p>
</li>
</ul>
<p><strong>heartbeat</strong></p>
<p>主从节点互相都会发送heartbeat信息:master默认每隔10秒发送一次heartbeat，salve node每隔1秒发送一个heartbeat</p>
<p><strong>异步复制</strong></p>
<p>master每次接收到写命令之后，现在内部写入数据，然后异步发送给slave node</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-redis主从架构搭建（一主一从）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/redis主从架构搭建（一主一从）/" class="article-date">
      <time datetime="2018-01-31T22:11:53.542Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>redis主从架构搭建（一主一从）</p>
<p>首先搭建一主一从，往主节点写，去从节点读</p>
<p>#####安装tcl和redis</p>
<ul>
<li><p>安装tcl</p>
<ul>
<li>wget <a href="http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</a></li>
<li>tar -xzvf tcl8.6.1-src.tar.gz</li>
<li>cd  /usr/local/tcl8.6.1/unix/</li>
<li>./configure  </li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li><p>安装redis</p>
<ul>
<li>将下载好的redis传到/usr/local目录中</li>
<li>tar -zxvf redis-3.2.8.tar.gz</li>
<li>cd redis-3.2.8</li>
<li>make &amp;&amp; make test &amp;&amp; make install</li>
</ul>
</li>
<li><p>redis具体操作</p>
<ul>
<li>将redis/utils/redis_init_script脚本拷贝到linux的/etc/init.d目录中，将redis_init_script重命名为redis_6379，6379是我们希望这个redis实例监听的端口号</li>
<li>修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）</li>
<li>创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件）</li>
<li>修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf</li>
<li>修改6379.conf文件</li>
</ul>
</li>
</ul>
<blockquote>
<p>daemonize yes    让redis以daemon进程运行</p>
<p>pidfile /var/run/redis_6379.pid 设置redis的pid文件位置</p>
<p>port    6379    设置redis的监听端口号</p>
<p>dir /var/redis/6379    设置持久化文件的存储位置</p>
</blockquote>
<ul>
<li>让redis跟随系统启动自动启动</li>
</ul>
<blockquote>
<p>修改/etc/init.d目录中的redis_6379，将下面两句放在最上面</p>
<p># chkconfig:   2345 90 10</p>
<p># description:  Redis is a persistent key-value database</p>
<p>执行命令chkconfig redis_6379 on</p>
</blockquote>
<ul>
<li>将这台机器中的redis配置为从节点（主节点之前已搭建过，请看前面的文章）<ul>
<li>修改6379.conf文件中的slaveof 192.168.1.1 6379</li>
<li>强制从节点只能接受读请求：slave-read-only yes</li>
<li>配置bind，将bind改为自己的IP（主从都要改为自己的IP，默认是127.0.0.1）</li>
</ul>
</li>
</ul>
<p>#####主从安全认证</p>
<ul>
<li><p>从节点配置masterauth:123456</p>
</li>
<li><p>主节点配置requirepass：123456</p>
</li>
</ul>
<p>至此一主一从redis架构搭建完成，在从节点使用redis-cli -h ipaddr启动redis</p>
<p>使用info replication命令可以查看该机器中的redis的角色，主节点等相关信息！</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-redis数据备份方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/redis数据备份方案/" class="article-date">
      <time datetime="2018-01-31T22:11:34.653Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>redis数据备份方案</p>
<p>redis数据备份方案一般有以下几种：</p>
<ol>
<li><p>写crontab定时调度脚本去做数据备份</p>
</li>
<li><p>每小时都copy一份rdb的备份，到一个目录中去，仅仅保留最近48小时的备份</p>
</li>
<li><p>每天都保留一份当日的rdb的备份，到一个目录中去，仅仅保留最近1个月的备份</p>
</li>
<li><p>每天晚上将当前服务器上所有的数据备份，发送一份到远程的云服务上去</p>
</li>
</ol>
<p><strong>注：</strong> 每次copy备份的时候，都把太旧的备份给删了</p>
<ul>
<li><strong>每小时copy一次备份，删除48小时前的数据</strong></li>
</ul>
<p>在/usr/local文件夹下创建redis文件夹，进入redis文件夹，创建copy和snapshotting两个文件夹，进入copy文件夹，创建文件redis_rdb_copy_hourly.sh并写入如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh </span><br><span class="line"></span><br><span class="line">cur_date=`date +%Y%m%d%H`</span><br><span class="line">rm -rf /usr/local/redis/snapshotting/$cur_date</span><br><span class="line">mkdir /usr/local/redis/snapshotting/$cur_date</span><br><span class="line">cp /var/redis/6379/dump.rdb /usr/local/redis/snapshotting/$cur_date</span><br><span class="line"></span><br><span class="line">del_date=`date -d -48hour +%Y%m%d%H`</span><br><span class="line">rm -rf /usr/local/redis/snapshotting/$del_date</span><br></pre></td></tr></table></figure>
<p>保存之后并赋予权限：chmod 777 redis_rdb_copy_hourly.sh</p>
<p>退出copy目录，在/usr/local/redis目录下输入crontab -e命令，并填写如下内容：</p>
<p>0 <em> </em> <em> </em> sh /usr/local/redis/copy/redis_rdb_copy_hourly.sh</p>
<p>保存退出</p>
<p>使用命令date -d -48hour +%Y%m%d%H查看当前时间，并在snapshotting目录下创建一个以这个时间为名称的目录，之后进入copy目录输入：./redis_rdb_copy_hourly.sh</p>
<p>进入snapshotting目录会发现之前创建的目录已经被删除，新创建了一个以当前时间为名称的目录，进入这个目录，如果你之前/var/redis/6379目录中有dump.rdb文件，会把这个文件copy到当前目录中</p>
<ul>
<li><strong>每天copy一次备份</strong></li>
</ul>
<p>同样是在copy目录中创建文件：redis_rdb_copy_daily.sh，并输入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh </span><br><span class="line"></span><br><span class="line">cur_date=`date +%Y%m%d`</span><br><span class="line">rm -rf /usr/local/redis/snapshotting/$cur_date</span><br><span class="line">mkdir /usr/local/redis/snapshotting/$cur_date</span><br><span class="line">cp /var/redis/6379/dump.rdb /usr/local/redis/snapshotting/$cur_date</span><br><span class="line"></span><br><span class="line">del_date=`date -d -1month +%Y%m%d`</span><br><span class="line">rm -rf /usr/local/redis/snapshotting/$del_date</span><br></pre></td></tr></table></figure>
<p>之后做法和每小时copy一份的操作一致，在此不再过多叙述，创建好之后可以使用同样的方式来测试是否成功。</p>
<ul>
<li><strong>数据恢复方案</strong></li>
</ul>
<ol>
<li><p>如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据</p>
</li>
<li><p>如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复</p>
</li>
<li><p>如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复</p>
</li>
<li><p>如果当前机器上的所有RDB文件全部损坏，那么从远程的云服务上拉取最新的RDB快照回来恢复数据</p>
</li>
<li><p>如果是发现有重大的数据错误，比如某个小时上线的程序一下子将数据全部污染了，数据全错了，那么可以选择某个更早的时间点，对数据进行恢复</p>
</li>
</ol>
<p>针对第二点：如果AOF日志文件破损可以使用redis-check-aof fix来恢复</p>
<p>针对第三点：一般是AOF和RDB两种同时打开的，而redis在启动时是优先使用AOF文件中的数据，所以正确的做法是，停止redis，关闭AOF，拷贝RDB文件，确认数据恢复，然后使用热修改redis配置，将AOF打开，这个时候redis就会将内存中的数据写入到AOF文件中，等全部写入之后，再手动把6379.conf文件中的AOF配置打开，然后关闭redis，重启redis，这个时候redis在启动时加载AOF文件就会有数据</p>
<p>以上就是redis数据备份方案。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-redis的AOF持久化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/redis的AOF持久化/" class="article-date">
      <time datetime="2018-01-31T22:11:20.536Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>redis的AOF持久化</p>
<p>本文主要是AOF持久化相关的操作</p>
<h5 id="AOF持久化配置"><a href="#AOF持久化配置" class="headerlink" title="AOF持久化配置"></a>AOF持久化配置</h5><p>AOF持久化配置默认是关闭的，RDB是默认打开的。打开AOF配置同样是在6379.conf文件中，找到appendonly，默认是appendonly no，改为appendonly yes。打开AOF持久化配置之后，redis每次接收到一条写命令，就会写入日志文件中，当然首先是写入os cache中，然后每隔一段时间就会fsync一下。</p>
<p>当AOF和RDB同时开启时，redis在启动时也会先加载AOF中的数据，因为AOF文件中的数据比较完整。</p>
<p>AOF的fsync策略可以进行配置，在6379.conf文件中有三种策略：</p>
<ul>
<li><p>always：每次写入一条数据，立即将这个数据对应的写日志fsync到磁盘中，性能差，吞吐量低</p>
</li>
<li><p>everysec：每秒将os Cache中的数据fsync到磁盘中，这个是最常用的</p>
</li>
<li><p>no：redis仅仅负责将数据写入到os cache中就不管了，os自己会是不是有自己的策略将数据刷入磁盘，这种方式是不可控的</p>
</li>
</ul>
<h5 id="AOF持久化的数据恢复实验"><a href="#AOF持久化的数据恢复实验" class="headerlink" title="AOF持久化的数据恢复实验"></a>AOF持久化的数据恢复实验</h5><ol>
<li><p>打开AOF持久化配置</p>
</li>
<li><p>使用redis写入几条数据，等待一秒左右</p>
</li>
<li><p>这时数据就会在/var/redis/6379文件夹中生成一份append.aof文件，这个文件中记录的是你之前操作redis的命令</p>
</li>
<li><p>使用kill-9暴力杀掉redis集成，然后重启redis（此处在重启redis的时候别忘了删除redis_6<br>379.pid文件）</p>
</li>
<li><p>使用get命令查找之前写入的数据，发现数据恢复了</p>
</li>
</ol>
<p><strong>注：</strong> 在append.aof文件中可以看到刚才的写的日志，它们其实是先写到os cache中，然后1s之后才fsync到磁盘中，只有fsync到磁盘中才是安全的，要不然光是写到os cache中，只要机器重启，数据就没了</p>
<h5 id="AOF-rewrite"><a href="#AOF-rewrite" class="headerlink" title="AOF rewrite"></a>AOF rewrite</h5><p>由于redis内存中存放的数据是有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除算法删除掉；redis中的数据会不断淘汰掉旧的，就只留一部分常用的数据在redis内存中。所以可能很多之前的旧的数据的命令存在AOF中，这样AOF会一直膨胀，所以AOF会自动在后台每隔一段时间做rewrite操作，比如日志里已经存放了针对100w数据的写日志了，redis内存中只剩下10w，基于内存中当前10w数据构建一套最新的日志到AOF中，覆盖之前的老日志，确保AOF文件不会过大，保持跟redis内存中数据一致。</p>
<p>在redis的2.4版本之前都是手工进行rewrite，在2.4之后会自动进行rewrite操作。</p>
<p>在6379.conf文件中可以进行配置：</p>
<p>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb</p>
<blockquote>
<p>比如上次AOF rewrite操作之后，是128mb，然后会接着128mb继续写AOF日志，如果发现增长的比例，超过了之前的100%，256mb，就可能进行一次rewrite操作，在进行rewrite操作之前会比较内存大小，只有大于了64mb才会去执行rewrite</p>
</blockquote>
<p><strong>AOF rewrite的过程：</strong></p>
<ol>
<li><p>redis会fork一个子进程</p>
</li>
<li><p>子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志</p>
</li>
<li><p>redis主进程，接收到client新的写操作之后，在内存中写入日志，同时也会往旧的AOF文件中写入日志</p>
</li>
<li><p>子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中</p>
</li>
<li><p>用新的日志文件替换旧的日志文件</p>
</li>
</ol>
<h5 id="AOF破损文件的修复"><a href="#AOF破损文件的修复" class="headerlink" title="AOF破损文件的修复"></a>AOF破损文件的修复</h5><p>如果redis在append日志到AOF文件的过程中，机器宕机了，可能会导致AOF文件破损，这时候可以使用redis-check-aof –fix命令来修复破损的文件</p>
<p><strong>注：</strong>这个命令会把最后一条不完整的数据去除，比如，在写的过程中，最后一条写日志不完整，使用这个命令之后会发现它会自动把最后一条不完整的写命令给去除</p>
<h5 id="AOF破损文件的修复-1"><a href="#AOF破损文件的修复-1" class="headerlink" title="AOF破损文件的修复"></a>AOF破损文件的修复</h5><ul>
<li><p>如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite操作，反之亦然</p>
</li>
<li><p>如果RDB在执行snapshotting时，用户手动执行BGREWRITEAOF操作，那么等RDB快照生成完成之后才会去执行BGREWRITEAOF操作</p>
</li>
<li><p>如果同时存在RDB和AOF文件，那么redis在启动时会优先加载AOF文件中数据，因为这个文件中的数据比较完整</p>
</li>
</ul>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-手撕HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/手撕HashMap/" class="article-date">
      <time datetime="2018-01-31T22:11:03.034Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>手撕HashMap</p>
<p>主要涉及以下几点：</p>
<ul>
<li>HashMap的数据结构</li>
<li>HashMap涉及的细节讨论</li>
<li>HashMap中的一些注意事项</li>
</ul>
<h5 id="一、HashMap数据结构"><a href="#一、HashMap数据结构" class="headerlink" title="一、HashMap数据结构"></a>一、HashMap数据结构</h5><p>HashMap的数据结构是由数组+链表组成</p>
<p><strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值查找，需要遍历数据的元素进行逐一对比，时间复杂度为O(n)</p>
<p><strong>链表</strong>：对于链表的新增、删除操作（在找到指定位置后），仅需处理节点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表进行逐一比对，时间复杂度为O(n)</p>
<p>所以为了快速定位并且能够快速的增删，使用了数组+链表的方式</p>
<h5 id="二、HashMap涉及的细节讨论"><a href="#二、HashMap涉及的细节讨论" class="headerlink" title="二、HashMap涉及的细节讨论"></a>二、HashMap涉及的细节讨论</h5><ul>
<li>写入时位置如何确定</li>
</ul>
<p>HashMap在put或者get时都会对key进行hash算法进行位置的确定：由于HashMap重写了equals和hashcode，put时对key算出hashcode，对hashcode进行hash算法，得出的值，和数组的长度length-1进行&amp;运算，得出位置下标。但是这种hash算法得出的位置可能是冲突的，所以用到了链表，将位置相同的key放在同一个位置中，使用链表将各个key进行关联。</p>
<p>数组中的每一个元素都是一个Entry对象，Entry对象中有K,V,next几个元素，其中next元素指向是下一个Entry对象，如果put时两个key算出的位置是一样的，后进来的对象放在该数组位置的头部，next指向之前存入的Entry对象。如果next没有元素就默认为null</p>
<p>如果put时key为null时，默认存放数组的第一个空间</p>
<p>所以HashMap的整体图大致如下：<br><img src="https://github.com/a511480568/image/blob/master/HashMap1.png?raw=true" alt="HashMap存储和取出整体图"></p>
<ul>
<li>hash算法</li>
</ul>
<p>hash算法设计的目的：快速定位到元素的位置并且得出的位置要尽量散列</p>
<p>如果hash函数设计的不好可能会导致：</p>
<blockquote>
<p>数组其他位置没有利用到，浪费存储空间</p>
<p>链表太长，说明我们的冲突概率太高，导致快存或者快取需要大量的逻辑判断，势必会影响存取效率</p>
</blockquote>
<ul>
<li>初始长度或者在扩容时为何都是2^n</li>
</ul>
<p>原因是参与hash算法运算的length-1，换算撑二进制，所有低位都是1，散列越分散；length-1如果换算撑二进制权位0越多，那么会造成冲突概率越多。</p>
<p>在HashMap中下标位置的确定流程是：<br><img src="https://github.com/a511480568/image/blob/master/HashMap2.png?raw=true" alt="HashMap中数组下标位置的确定"></p>
<p>所以HashMap的数组长度一定是2的次幂，这样在做位运算时能够散列开，并且数组进行扩容时，需要对index进行重新计算，扩容的长度也是2的次幂，计算index时也是length-1，这样会尽量保证位置是散列开的，如果低位中其中一个是0，那么在进行&amp;运算时就可能会有一半的概率发生哈希碰撞</p>
<p>权位都是1，算出的index会更加散列开：</p>
<p><img src="https://github.com/a511480568/image/blob/master/HashMap3.png?raw=true" alt="hashmap位运算"></p>
<p>如果低位中有一个为0，那么算出的位置发生哈希冲突的概率会大大提高：</p>
<p><img src="https://github.com/a511480568/image/blob/master/HashMap4.png?raw=true" alt="hashmap位运算"></p>
<h5 id="三、HashMap注意"><a href="#三、HashMap注意" class="headerlink" title="三、HashMap注意"></a>三、HashMap注意</h5><ul>
<li>为何要重写equals和hashcode方法</li>
</ul>
<p>如果只重写了equals而没有重写hashcode方法的话，得出的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsAndHashCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> idCard;</span><br><span class="line">		</span><br><span class="line">		String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idCard,String name)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.idCard = idCard;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span> == obj &amp;&amp; <span class="keyword">this</span>.hashCode() == obj.hashCode())&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">null</span> == obj || getClass() != obj.getClass())&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Person person = (Person)obj;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.hashCode() == person.hashCode()) &amp;&amp; (<span class="keyword">this</span>.idCard == person.idCard);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//HashMap&lt;Person, String&gt; map = new HashMap&lt;EqualsAndHashCode.Person, String&gt;();</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="number">666</span>, <span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(<span class="string">"equals结果："</span>+ <span class="keyword">new</span> Person(<span class="number">666</span>, <span class="string">"123"</span>).equals(person));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得出的结果为：equals结果：false</p>
<p>如果上述代码中重写了hashcode：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsAndHashCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> idCard;</span><br><span class="line">		</span><br><span class="line">		String name;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idCard,String name)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.idCard = idCard;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> idCard % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span> == obj &amp;&amp; <span class="keyword">this</span>.hashCode() == obj.hashCode())&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">null</span> == obj || getClass() != obj.getClass())&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Person person = (Person)obj;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.hashCode() == person.hashCode()) &amp;&amp; (<span class="keyword">this</span>.idCard == person.idCard);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//HashMap&lt;Person, String&gt; map = new HashMap&lt;EqualsAndHashCode.Person, String&gt;();</span></span><br><span class="line">		Person person = <span class="keyword">new</span> Person(<span class="number">666</span>, <span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(<span class="string">"equals结果："</span>+ <span class="keyword">new</span> Person(<span class="number">666</span>, <span class="string">"123"</span>).equals(person));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得出的结果为：equals结果：true</p>
<p>所以在使用map时会根据这个来判断</p>
<ul>
<li>手撕HashMap</li>
</ul>
<p>废话不说，直接上代码：</p>
<p>接口类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//存入数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义默认数组大小为16</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultLenght = <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br><span class="line">	<span class="comment">//扩容标准：使用的useSize/数组长度&gt;0.75</span></span><br><span class="line">	<span class="comment">//defaultAddSizeFactor过大造成扩容概率过低</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> defaultAddSizeFactor = <span class="number">0.75</span>;</span><br><span class="line">	<span class="comment">//使用数组位置</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> useSize;</span><br><span class="line">	<span class="comment">//定义entry数组</span></span><br><span class="line">	<span class="keyword">private</span> Entry&lt;K,V&gt;[] table = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//定义扩容后的entry</span></span><br><span class="line">	<span class="keyword">private</span> Entry&lt;K,V&gt;[] newTable = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">double</span> defaultAddSizeFactor)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(length &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"长度不能为负数:"</span>+length);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(defaultAddSizeFactor &lt;=<span class="number">0</span> || Double.isNaN(defaultAddSizeFactor))&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"扩容因子不合法:"</span>+defaultAddSizeFactor);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.defaultLenght = length;</span><br><span class="line">		<span class="keyword">this</span>.defaultAddSizeFactor = defaultAddSizeFactor;</span><br><span class="line">		table = <span class="keyword">new</span> Entry[defaultLenght];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断数组使用的长度</span></span><br><span class="line">		<span class="keyword">if</span>(useSize &gt; defaultAddSizeFactor * defaultLenght)&#123;</span><br><span class="line">			<span class="comment">//进行扩容</span></span><br><span class="line">			up2Size();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据key和数组长度获取角标位置</span></span><br><span class="line">		<span class="keyword">int</span> index = getIndex(key,table.length);</span><br><span class="line">		Entry&lt;K,V&gt; entry = table[index];</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> == entry)&#123;</span><br><span class="line">			<span class="comment">//说明，数组的这个位置没有使用，将数据写入这个entry对象,next为null</span></span><br><span class="line">			table[index] = <span class="keyword">new</span> Entry(key,value,<span class="keyword">null</span>);</span><br><span class="line">			useSize++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//说明，这个位置被使用了，需要将数据放入这个位置的头部，原来的数据放在新存入数据的next对象中，形成链表</span></span><br><span class="line">			table[index] = <span class="keyword">new</span> Entry(key,value,entry);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> table[index].getValue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = getIndex(key, table.length);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> == table[index])&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//key存在的情况</span></span><br><span class="line">		<span class="keyword">return</span> findValueByEqualKey(key,table[index]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//可能存在不同的key在同一位置上形成链表结构</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> V <span class="title">findValueByEqualKey</span><span class="params">(K key, MyHashMap&lt;K, V&gt;.Entry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(key == entry.getKey() || key.equals(entry.getKey()))&#123;</span><br><span class="line">			<span class="keyword">return</span> entry.getValue();</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">null</span> != entry.next)&#123;</span><br><span class="line">			findValueByEqualKey(key, entry.next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">up2Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//进行数组扩容，扩容到原来的两倍</span></span><br><span class="line">		newTable = <span class="keyword">new</span> Entry[<span class="number">2</span> * defaultLenght];</span><br><span class="line">		<span class="comment">//重新进行hash算法，因为hash算法用到了数组的长度，这时数组的长度发生了变化，需要重新进行hash算法，对每个元素算出相应的位置</span></span><br><span class="line">		againHash(newTable);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">againHash</span><span class="params">(MyHashMap&lt;K, V&gt;.Entry&lt;K, V&gt;[] newTable2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义一个entryList用来存放entry对象</span></span><br><span class="line">		List&lt;Entry&lt;K,V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;MyHashMap&lt;K,V&gt;.Entry&lt;K,V&gt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">null</span> == table[i])&#123;</span><br><span class="line">				<span class="comment">//说明这个位置上没有数据，跳过这次查询，对下个位置进行判断</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//继续找存到数组上的entry对象</span></span><br><span class="line">			foundEntryByNext(table[i],entryList);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(entryList.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			defaultLenght = <span class="number">2</span> * defaultLenght;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(Entry&lt;K,V&gt; entry : entryList)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">null</span> != entry)&#123;</span><br><span class="line">					<span class="comment">//在循环遍历时，对链表上的数据存入list中，但是现在需要对entry对象重新put进行hash算法，所以需要把next清空</span></span><br><span class="line">					entry.next = <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				useSize = <span class="number">0</span>;</span><br><span class="line">				put(entry.getKey(), entry.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foundEntryByNext</span><span class="params">(MyHashMap&lt;K, V&gt;.Entry&lt;K, V&gt; entry,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;MyHashMap&lt;K, V&gt;.Entry&lt;K, V&gt;&gt; entryList)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != entry &amp;&amp; <span class="keyword">null</span> != entry.next)&#123;</span><br><span class="line">			<span class="comment">//说明该位置存在链表，需要进行递归，对链表上的数据进行遍历</span></span><br><span class="line">			entryList.add(entry);</span><br><span class="line">			foundEntryByNext(entry.next, entryList);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//该位置上不存在链表</span></span><br><span class="line">			entryList.add(entry);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(K key, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//数组长度减一得到的二进制低位都是1，在做&amp;运算时可以使得到的位置更散列</span></span><br><span class="line">		<span class="keyword">int</span> c = length - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//对key的hashcode进行hash算法得到的值和数组长度减一进行&amp;运算</span></span><br><span class="line">		<span class="keyword">int</span> index = hash(key.hashCode()) &amp; c;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">		hashCode = hashCode ^ ((hashCode &gt;&gt;&gt; <span class="number">20</span>) ^ (hashCode &gt;&gt;&gt; <span class="number">12</span>));</span><br><span class="line">		<span class="keyword">return</span> hashCode ^ ((hashCode &gt;&gt;&gt; <span class="number">7</span>) ^ (hashCode &gt;&gt;&gt; <span class="number">4</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个内部存储对象，实现mymap中的entry接口</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">MyMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">		</span><br><span class="line">		K k;</span><br><span class="line">		V v;</span><br><span class="line">		<span class="comment">//指向下一个entry</span></span><br><span class="line">		Entry&lt;K,V&gt; next;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K k,V v,Entry&lt;K,V&gt; next)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.k = k;</span><br><span class="line">			<span class="keyword">this</span>.v = v;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> k;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> v;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是HashMap的简单实现，如有不对，请指正！</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Redis的RDB持久化配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/Redis的RDB持久化配置/" class="article-date">
      <time datetime="2018-01-31T22:10:45.077Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Redis的RDB持久化配置</p>
<p>关于RDB持久化有以下几点：</p>
<ul>
<li>如何配置RDB持久化</li>
<li>RDB持久化机制的工作流程</li>
<li>基于RDB持久化机制数据恢复的实验</li>
</ul>
<h5 id="一、如何配置RDB持久化"><a href="#一、如何配置RDB持久化" class="headerlink" title="一、如何配置RDB持久化"></a>一、如何配置RDB持久化</h5><p>RDB持久化的配置在/etct/redis/6379.conf文件中，之前文章有讲到<a href="http://176.122.175.92:2368/linuxzhong-an-zhuang-redis/" target="_blank" rel="noopener">Linux中安装redis及开发和生产启动redis</a>。6379.conf文件中默认会有几种配置方式：</p>
<blockquote>
<p>save 900 1</p>
<p>save 300 10</p>
<p>save 60 10000</p>
</blockquote>
<p>意思是：每900s有一个key发生了变更，那么就会生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照；save可以设置多个，就是多个snapshotting检查点，每到一个检查点就会check一下，是否有指定的key发生了变更，如果有就会生成一份新的dump.rdb文件来覆盖之前旧的文件</p>
<h5 id="二、RDB持久化机制工作流程"><a href="#二、RDB持久化机制工作流程" class="headerlink" title="二、RDB持久化机制工作流程"></a>二、RDB持久化机制工作流程</h5><ol>
<li>redis根据配置自己去尝试生成rdb快照文件</li>
<li>fork一个子进程出来</li>
<li>子进程尝试将数据dump到临时的rdb文件中</li>
<li>完成rdb快照文件的生成后，就替换之前的老文件</li>
</ol>
<h5 id="三、数据恢复实验"><a href="#三、数据恢复实验" class="headerlink" title="三、数据恢复实验"></a>三、数据恢复实验</h5><ul>
<li>首先在redis中保存几条数据，然后停掉redis进程（redis-cli SHUTDOWN 正常停止），然后重启redis，发现数据仍然存在<blockquote>
<p>正常退出redis其实是一种安全退出模式，redis在退出时会立即生成一份快照文件保存在/var/redis/6379/dump.rdb中</p>
</blockquote>
</li>
</ul>
<p>操作图如下：<br><img src="https://github.com/a511480568/image/blob/master/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE1.jpg?raw=true" alt="RDB持久化配置正常停止"></p>
<ul>
<li><p>在redis中再保存几条数据，使用kill-9粗暴杀掉进程，然后再重新启动redis查看，数据没有保存，操作方式和上图一样，只不过关闭redis进程的方式不一样（此处使用kill-9 杀掉进程，启动redis之前，还需要删除/var/run/redis_6379.pid文件，否则会报错）</p>
</li>
<li><p>手动在6379.conf文件中设置一个save 5 1</p>
</li>
<li><p>写入几条数据，等待5s，然后查看dump.rdb文件会发现你之前set的值会进行保存</p>
</li>
<li><p>然后再粗暴杀掉redis进程，重启redis，get取出之前的key会发现能够正常取出</p>
</li>
</ul>
<p>以上就是redis中RDB持久化方式的配置以及简单实验</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-缓存穿透、缓存并发、热点缓存之最佳招式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/缓存穿透、缓存并发、热点缓存之最佳招式/" class="article-date">
      <time datetime="2018-01-31T22:10:28.122Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>缓存穿透、缓存并发、热点缓存之最佳招式</p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>我们在用缓存的时候，不管是Redis或者Memcached，基本上会通用遇到以下三个问题：</p>
<ul>
<li>缓存穿透</li>
<li>缓存并发</li>
<li><p>缓存失效</p>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><font color="green">缓存穿透<font></font></font></h5><p><img src="https://github.com/a511480568/image/blob/master/wechat_img1.jpg?raw=true" alt="有个业务逻辑"><br><img src="https://github.com/a511480568/image/blob/master/wechat_img2.jpg?raw=true" alt="管理后台业务"><br><img src="https://github.com/a511480568/image/blob/master/wechat_img3.jpg?raw=true" alt="管理后台业务逻辑变更为"></p>
</li>
</ul>
<p>上面三个图会有什么问题呢？</p>
<p>我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。</p>
<p>要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<p>有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个值:比如，”key” , “&amp;&amp;”</p>
<p>在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p>
<h5 id="缓存并发"><a href="#缓存并发" class="headerlink" title="缓存并发"></a><font color="green">缓存并发<font></font></font></h5><p>有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p>
<p>我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<p>这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。</p>
<h5 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a><font color="green">缓存失效<font></font></font></h5><p>引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p>
<p>那如何解决这些问题呢？</p>
<p>其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p>我们讨论的第二个问题时针对同一个缓存，第三个问题时针对很多缓存。</p>
<p>总结来看：</p>
<ol>
<li>缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。</li>
<li>缓存失效：如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。</li>
</ol>
<h5 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a><font color="green">问题汇总<font></font></font></h5><h6 id="emsp-问题1"><a href="#emsp-问题1" class="headerlink" title="&emsp;问题1:"></a><font color="green">&emsp;问题1:<font></font></font></h6><p>如何解决DB和缓存一致性问题？</p>
<p>答：当修改了数据库后，有没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。</p>
<h6 id="emsp-问题2"><a href="#emsp-问题2" class="headerlink" title="&emsp;问题2:"></a><font color="green">&emsp;问题2:<font></font></font></h6><p>问下缓存穿透那块！例如，一个用户查询文章，通过ID查询，按照之前说的，是将缓存的KEY预先设置一个值，，如果通过ID插过来，发现是预先设定的一个值，比如说是“&amp;&amp;”，那之后的继续等待访问是什么意思，这个ID什么时候会真正被附上用户所需要的值呢？</p>
<p>答：我刚说的主要是咱们常用的后面配置，前台获取的场景。前台无法获取相应的key，则等待，或者放弃。当在后台配置界面上配置了相关key和value之后，那么以前的key &amp;&amp;也自然会被替换掉。你说的那种情况，自然也应该会有一个进程会在某一个时刻，在缓存中设置这个ID，再有新的请求到达的时候，就会获取到最新的ID和value。</p>
<h6 id="emsp-问题3"><a href="#emsp-问题3" class="headerlink" title="&emsp;问题3:"></a><font color="green">&emsp;问题3:<font></font></font></h6><p>其实用redis的话，那天看到一个不错的例子，双key，有一个当时生成的一个附属key来标识数据修改到期时间，然后快到的时候去重新加载数据，如果觉得key多可以把结束时间放到主key中，附属key起到锁的功能。</p>
<p>答：这种方案，之前我们实践过。这种方案会产生双份数据，而且需要同时控制附属key与key之间的关系，操作上有一定复杂度。</p>
<h6 id="emsp-问题4"><a href="#emsp-问题4" class="headerlink" title="&emsp;问题4:"></a><font color="green">&emsp;问题4:<font></font></font></h6><p>多级缓存是什么概念呢？</p>
<p>答：多级缓存就像我今天之前给大家发的文章里面提到了，将ehcache与redis做二级缓存，就像我之前写的文章 <a href="http://www.jianshu.com/p/2cd6ad416a5a" target="_blank" rel="noopener">http://www.jianshu.com/p/2cd6ad416a5a</a> 提到过的。但同样会存在一致性问题，如果我们需要强一致性的话，缓存与数据库同步是会存在时间差的，所以我们在具体开发的过程中，一定要根据场景来具体分析，二级缓存更多的解决是，缓存穿透与程序的健壮性，当集中式缓存出现问题的时候，我们的应用能够继续运行。</p>
<h3 id="二、缓存穿透与并发方案"><a href="#二、缓存穿透与并发方案" class="headerlink" title="二、缓存穿透与并发方案"></a>二、缓存穿透与并发方案</h3><p>上文中介绍了关于缓存穿透、并发的一些常用思路，但是没有明确一些思路的使用场景，下面继续深入探讨。相信不少朋友之前看过很多类似的文章，但是归根结底就是二个问题：</p>
<ul>
<li>如何解决穿透</li>
<li>如何解决并发</li>
</ul>
<p>当并发较高的时候，其实我是不建议使用缓存过期这个策略的，我更希望缓存一直存在，通过后台系统来更新缓存系统中的数据达到数据的一致性目的，有的朋友可能会质疑，如果缓存系统挂了怎么办，这样数据库更新了但是缓存没有更新，没有达到一致性的状态。</p>
<font color="red">解决问题的思路是：</font>

<p>如果缓存是因为网络问题没有更新成功数据，那么建议重试几次，如果依然没有更新成功则认为缓存系统出错不可用，这时候客户端会将数据的KEY插入到消息系统中，消息系统可以过滤相同的KEY，只需保证消息系统不存在相同的KEY，当缓存系统恢复可用的时候，依次从mq中取出KEY值然后从数据库中读取最新的数据更新缓存。注意：更新缓存之前，缓存中依然有旧数据，所以不会造成缓存穿透。</p>
<p>下图展示了整个思路的过程：<br><img src="https://github.com/a511480568/image/blob/master/wechat_img4.jpg?raw=true" alt="ff"><br>看完上面的方案以后，又会有不少朋友提出疑问，如果我是第一次使用缓存或者缓存中暂时没有我需要的数据，那又该如何处理呢？</p>
<font color="red">解决问题的思路是：</font>

<p>在这种场景下，客户端从缓存中根据KEY读取数据，如果读到了数据则流程结束，如果没有读到数据（可能会有多个并发都没有读到数据），这时候使用缓存系统中的setNX方法设置一个值（这种方法类似加个锁），没有设置成功的请求则sleep一段时间，设置成功的请求读取数据库获取值，如果获取到则更新缓存，流程结束，之前sleep的请求这时候唤醒后直接再从缓存中读取数据，此时流程结束。</p>
<p>在看完这个流程后，我想这里面会有一个漏洞，如果数据库中没有我们需要的数据该怎么处理，如果不处理则请求会造成死循环，不断的在缓存和数据库中查询，这时候我们会沿用我之前文章中的如果没有读到数据则往缓存中插入一个NULL字符串的思路，这样其他请求直接就可以根据“NULL”进行处理，直到后台系统在数据库成功插入数据后同步更新清理NULL数据和更新缓存。</p>
<p>流程图如下所示：<br><img src="https://github.com/a511480568/image/blob/master/wechat_img5.jpg?raw=true" alt="ff"></p>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>在实际工作中，我们往往将上面二个方案组合使用才能达到最佳效果，虽然第二种方案也会造成请求阻塞，但是只是在第一次使用或者缓存暂时没有数据的情况下才会产生，在生产中经过检验在TPS没有上万的情况下是不会造成问题的。</p>
<h3 id="三、热点缓存解决方案"><a href="#三、热点缓存解决方案" class="headerlink" title="三、热点缓存解决方案"></a>三、热点缓存解决方案</h3><ul>
<li>缓存使用背景：</li>
</ul>
<p>我们拿用户中心的一个案例来说明：<br>每个用户都会首先获取自己的用户信息，然后再进行其他相关的操作，有可能会有如下一些场景情况：</p>
<blockquote>
<p>会有大量相同用户重复访问该项目。</p>
<p>会有同一用户频繁访问同一模块。</p>
</blockquote>
<ul>
<li>思路解析:</li>
</ul>
<blockquote>
<p>因为用户本身是不固定的而且用户数量也有几百万尤其上千万，我们不可能把所有的用户信息全部缓存起来，通过第一个场景情况可以看到一些规律，那就是有大量的相同用户重复访问，但是究竟是哪些用户重复访问我们也并不知道。</p>
<p>如果有一个用户频繁刷新读取项目，那么对数据库本身也会造成较大压力，当然我们也会有相关的保护机制来确实恶意攻击，可以从前端控制，也可以有采黑名单等机制，这里不在赘述。如果用缓存的话，我们又该如何控制同一用户繁重读取用户信息呢。</p>
</blockquote>
<p>请看下图：<br><img src="https://github.com/a511480568/image/blob/master/wechat_img6.jpg?raw=true" alt=""></p>
<p>我们会通过缓存系统做一个排序队列，比如1000个用户，系统会根据用户的访问时间更新用户信息的时间，越是最近访问的用户排名越排前，系统会定期过滤掉排名最后的200个用户，然后再从数据库中随机取出200个用户加入队列，这样请求每次到达的时候，会先从队列中获取用户信息，如果命中则根据userId，再从另一个缓存数据结构中读取用户信息，如果没有命中则说明该用户请求频率不高。</p>
<p>这篇文章转载于：<a href="https://mp.weixin.qq.com/s/62KJ2mSTGoUTPsq0RjU7lg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/62KJ2mSTGoUTPsq0RjU7lg</a></p>
<p>如有侵权，请告知。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-redis持久化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/01/redis持久化/" class="article-date">
      <time datetime="2018-01-31T22:10:05.929Z" itemprop="datePublished">2018-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>redis持久化</p>
<p>redis持久化的意义在于故障恢复；比如部署了一台redis，作为cache缓存，数据存放在内存中，如果redis发生了灾难性的故障，我们把redis恢复之后数据是无法恢复的。</p>
<p>如果redis持久化到磁盘上，再将磁盘上的数据备份一份放在云上（比如阿里云的ODPS）。如果发生了灾难性的故障，磁盘中的数据也一时半会无法取到，可以另外起一台redis，然后从云上把数据拉到硬盘上，redis在启动时就会把磁盘中的数据加入到内存中，具体如下图：<br><img src="https://github.com/a511480568/image/blob/master/redisPersistence.png?raw=true" alt="redis持久化"></p>
<p>redis的两种持久化机制：RDB和AOF</p>
<h5 id="两种机制介绍"><a href="#两种机制介绍" class="headerlink" title="两种机制介绍"></a>两种机制介绍</h5><ul>
<li>RDB持久化机制，对redis中的数据进行周期性的持久化</li>
</ul>
<blockquote>
<p>比如在12:00时redis中有2000条数据，此时redis向RDB中进行一次持久化，12:30时redis中有3500条数据，此时redis再次进行一次持久化，此时RDB中有3500条数据。RDB每隔几分钟或者几小时或者几天，生成一份redis内存中数据的一份完整的快照。</p>
</blockquote>
<ul>
<li>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件，在redis重启的时候可以通过回放AOF日志中的写入指令来重新构建整个数据集</li>
</ul>
<blockquote>
<p>每当有一条数据进入redis时，redis就会写入到AOF文件中；然而redis中的数据，是有一定限量的，不可能说redis内存中的数据无限增长，进而导致AOF无限增长。内存大小是一定的，到一定时候，redis就会用缓存淘汰算法，LRU，自动将一部分数据清除。由于内存的数据是一定量的，AOF是存放每条写命令的，所以会不断的膨胀，当大到一定的时候，AOF做rewrite操作。AOF的rewrite操作，就会基于当时redis内存中的数据生成一份小的AOF文件，然后将旧的膨胀的AOF文件给删除</p>
</blockquote>
<p><img src="https://github.com/a511480568/image/blob/master/RDB%E5%92%8CAOF%E7%9A%84%E4%BB%8B%E7%BB%8D.png?raw=true" alt="RDB和AOF的介绍"></p>
<p><img src="https://github.com/a511480568/image/blob/master/AOF%20rewrite%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90.png?raw=true" alt="AOF rewrite原理剖析"></p>
<p>对于第二张图可以理解为：redis对AOF的操作</p>
<ol>
<li><p>比如redis限定了总内存大小只能存放1G的数据，当外部向redis写入100w条数据时就达到了1G，由于外部每往redis中写入一条数据，redis就会向AOF中存放一条数据，所以此时AOF中也有100w条数据了。</p>
</li>
<li><p>此时redis内存达到了最大值，就会将最不经常使用的数据，从内存中删除，比如此时redis清除了50w条数据</p>
</li>
<li><p>外部接着往redis内存中写入数据，当redis再一次达到最大内存比如还是100w条数据，此时AOF文件中就有150w条数据</p>
</li>
<li><p>此时AOF就会创建一个新的来存放当前redis内存中的100w条数据，把旧的AOF文件删除</p>
</li>
</ol>
<font color="red">综上所述：通过RDB和AOF都可以对redis内存中的数据持久化到磁盘中，然后将磁盘中的数据备份到云服务上。如果redis挂了，服务器的内存中和磁盘中的数据都丢失了，可以从云服务上拷贝回来，放到指定目录中，重启redis，redis就会自动根据持久化文件中的数据恢复到内存中。<br><br>如果同时使用RDB和AOF两种持久化机制，那么在redis重启时，会使用AOF来重新构建之前的数据，因为AOF中的数据更加完整！<br></font>

<h5 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h5><h6 id="emsp-emsp-RDB的优点"><a href="#emsp-emsp-RDB的优点" class="headerlink" title="&emsp;&emsp;RDB的优点"></a>&emsp;&emsp;RDB的优点</h6><ul>
<li>RDB会生成多份文件，每个数据文件都代表了某个时刻redis的数据，这种多个数据文件的方式，特别适合做冷备份，可以将完整的数据文件发送到云服务上，以预定好的备份策略来定期备份redis数据</li>
</ul>
<blockquote>
<p>RDB做冷备份，生成多个文件，每个文件都代表了某个时刻redis的数据</p>
<p>AOF也可以做冷备份，虽然只有一个文件，但可以每隔一段时间就复制一份这个文件</p>
</blockquote>
<ul>
<li>RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</li>
</ul>
<blockquote>
<p>RDB，每次写，都是直接写redis内存，只是在一定时候，才会将数据写入磁盘</p>
<p>AOF，每次都要写入磁盘，虽然可以快速写入 os cache中，但还是有一定的时间开销，比RDB方式时间略长一些</p>
</blockquote>
<ul>
<li>相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis，更加快速</li>
</ul>
<blockquote>
<p>AOF，存放的是指令日志，做数据恢复时，其实是要回放和执行这些日志指令来恢复出来内存中的数据</p>
<p>RDB中存放的就是数据，恢复的时候直接加载到内存中即可</p>
</blockquote>
<h6 id="emsp-emsp-RDB的缺点"><a href="#emsp-emsp-RDB的缺点" class="headerlink" title="&emsp;&emsp;RDB的缺点"></a>&emsp;&emsp;RDB的缺点</h6><ul>
<li>数据恢复没有AOF好</li>
</ul>
<blockquote>
<p>比如RDB，每五分钟写入一次数据，如果在这五分钟内redis进程挂了，那么这五分钟内的数据就丢失了，这个问题也是RDB最大的缺点</p>
</blockquote>
<ul>
<li>RDB每次在fork子进程来执行rdb快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停几毫秒甚至几秒</li>
</ul>
<blockquote>
<p>一般不要让RDB的时间间隔太长，否则每次生成的RDB文件太大了，对redis本身的性能可能会有影响</p>
</blockquote>
<h6 id="emsp-emsp-AOF优点"><a href="#emsp-emsp-AOF优点" class="headerlink" title="&emsp;&emsp;AOF优点"></a>&emsp;&emsp;AOF优点</h6><ol>
<li><p>AOF可以更好的保护数据不丢失，一般AOF会每隔1s，通过一个后台进程执行一次fsync操作，最多丢失1s的数据</p>
</li>
<li><p>AOF日志文件以appen-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易恢复</p>
</li>
<li><p>AOF文件过大的时候，出现后台重写操作，也不会影响客户端读写。因为在rewrite log的时候会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p>
</li>
<li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
</li>
</ol>
<h6 id="emsp-emsp-AOF缺点"><a href="#emsp-emsp-AOF缺点" class="headerlink" title="&emsp;&emsp;AOF缺点"></a>&emsp;&emsp;AOF缺点</h6><ol>
<li><p>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>
</li>
<li><p>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>
</li>
<li><p>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p>
</li>
<li><p>唯一的比较大的缺点，其实就是做数据恢复的时候，会比较慢，还有做冷备，定期的备份，不太方便，可能要自己手写复杂的脚本去做，做冷备不太合适</p>
</li>
</ol>
<h6 id="emsp-emsp-两者的选择"><a href="#emsp-emsp-两者的选择" class="headerlink" title="&emsp;&emsp;两者的选择"></a>&emsp;&emsp;两者的选择</h6><ol>
<li><p>不要仅仅使用RDB，因为那样会导致你丢失很多数据</p>
</li>
<li><p>也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug</p>
</li>
<li><p>综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复</p>
</li>
</ol>
<p>以上就是redis持久化的相关概念及优缺点</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Linux中安装redis及开发和生产启动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/31/Linux中安装redis及开发和生产启动/" class="article-date">
      <time datetime="2018-01-31T11:56:18.018Z" itemprop="datePublished">2018-01-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Linux中安装redis及开发和生产启动redis</p>
<p>在Linux中安装redis其实很简单，只需要将下载好的redis压缩包放进相应目录中即可（我是放在/usr/local中）。安装好redis后，启动redis有两种方式：开发模式和生产模式.</p>
<h4 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h4><p>如果只是在开发模式下启动redis来做实验只需要进入安装好的redis目录中的src文件（/usr/local/redis-3.2.8/src）来启动服务端和客户端即可：</p>
<blockquote>
<p>启动服务端：./redis-server</p>
<p>启动客户端：./redis-cli</p>
</blockquote>
<h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><p>但生产环境是跟着服务器启动的，并不能使用./redis-server来启动，否则客户终端断开redis就挂了。生产环境启动redis可以参照如下：</p>
<ul>
<li>我们安装好的redis目录下有个utils目录，将utils目录中的redis_init_script复制到/etc/init.d目录中，并重新命名为redis_6379（6379是我们希望这个redis实例监听的端口号）</li>
<li>修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）</li>
<li>创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件）</li>
<li>修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf</li>
<li>修改6379.conf中的部分配置为生产环境:</li>
</ul>
<blockquote>
<p>daemonize &emsp; <font color="#0099ff">yes</font> &emsp;    让redis以daemon进程运行</p>
<p>pidfile  &emsp;   <font color="#0099ff">/var/run/redis_6379.pid</font> &emsp; 设置redis的pid文件位置</p>
<p>port   &emsp;  <font color="#0099ff">6379</font> &emsp; 设置redis的监听端口号</p>
<p>dir    &emsp; <font color="#0099ff">/var/redis/6379</font> &emsp; 设置持久化文件的存储位置</p>
</blockquote>
<ul>
<li>设置开机启动redis</li>
</ul>
<blockquote>
<p>在上面之前修改过的redis_6379中的最上面增加两行注释：</p>
<p># chkconfig: &emsp;  2345 90 10</p>
<p># description: &emsp; Redis is a persistent key-value database</p>
<p>运行命令： chkconfig redis_6379 on</p>
</blockquote>
<ul>
<li>启动redis</li>
</ul>
<blockquote>
<p>cd /etc/init.d</p>
<p>./redis_6379 start</p>
</blockquote>
<ul>
<li>查看redis进程</li>
</ul>
<blockquote>
<p>ps -ef | grep redis</p>
</blockquote>
<ul>
<li>关闭redis</li>
</ul>
<blockquote>
<p>redis-cli SHUTDOWN</p>
</blockquote>
<p>以上就是开发环境和生产环境中redis的启动方法，如有错误请指出！</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 Yashon
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>